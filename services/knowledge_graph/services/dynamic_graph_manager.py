# services/knowledge_graph/services/dynamic_graph_manager.py

"""
Dynamic Knowledge Graph Manager

This service manages the dynamic, multi-layered knowledge graph that sits on top
of the static lab_tutor knowledge base. It handles:
1. Teacher nodes and administrative privileges
2. Student nodes and progress tracking
3. Content nodes (Topic, Concept, Lab, Quiz, Assessment)
4. Question nodes generated by LLM
5. Resource nodes (external learning materials)
6. All relationships between these entities
"""

from typing import Dict, List, Any, Optional, Tuple
import json
from datetime import datetime
from pathlib import Path
import sys

# Use neo4j driver directly instead of importing from lab_tutor
try:
    from neo4j import GraphDatabase
    NEO4J_AVAILABLE = True
except ImportError:
    print("Warning: neo4j driver not available. Install with: pip install neo4j")
    NEO4J_AVAILABLE = False
    GraphDatabase = None


class SimpleNeo4jConnection:
    """Simple Neo4j connection wrapper"""
    def __init__(self, uri, username, password):
        if not NEO4J_AVAILABLE:
            raise Exception("neo4j driver not available")
        self.driver = GraphDatabase.driver(uri, auth=(username, password))
        self.driver.verify_connectivity()
        # Create graph wrapper once
        self._graph = self.GraphWrapper(self.driver)

    class GraphWrapper:
        """Wrapper to provide .graph.query() interface"""
        def __init__(self, driver):
            self.driver = driver

        def query(self, cypher_query, params=None, **kwargs):
            """Execute a Cypher query and return results"""
            with self.driver.session() as session:
                # Support both dict params and keyword params
                if params is not None:
                    result = session.run(cypher_query, params)
                elif kwargs:
                    result = session.run(cypher_query, **kwargs)
                else:
                    result = session.run(cypher_query)
                return list(result)

    @property
    def graph(self):
        """Provide .graph property for compatibility"""
        return self._graph

    def close(self):
        """Close the driver connection"""
        if self.driver:
            self.driver.close()


class DynamicGraphManager:
    """
    Manages the dynamic knowledge graph layer on top of the static lab_tutor content.
    
    This class provides CRUD operations for:
    - Teacher management
    - Student enrollment and progress tracking
    - Content hierarchy (Topics, Concepts, Labs, Quizzes)
    - Assessment questions and results
    - Learning resources and recommendations
    """
    
    def __init__(self, neo4j_connection=None):
        """
        Initialize the Dynamic Graph Manager.

        Args:
            neo4j_connection: Optional Neo4j connection. If None, creates a new one.
        """
        if neo4j_connection is None and NEO4J_AVAILABLE:
            try:
                # Use the correct password for KTCD Neo4j instance
                self.neo4j = SimpleNeo4jConnection(
                    uri="bolt://localhost:7687",
                    username="neo4j",
                    password="ktcd_password123"
                )
                print("âœ“ Connected to Neo4j successfully")
            except Exception as e:
                print(f"âœ— Could not connect to Neo4j: {e}")
                self.neo4j = None
        else:
            self.neo4j = neo4j_connection

        self.static_content_loaded = False
        
    def initialize_schema(self):
        """Create constraints and indexes for the dynamic knowledge graph."""
        if self.neo4j is None:
            print("Neo4j not available, skipping schema initialization")
            return
        
        print("ðŸ”§ Initializing Dynamic Knowledge Graph Schema...")
        
        # Node constraints
        constraints = [
            "CREATE CONSTRAINT teacher_id_unique IF NOT EXISTS FOR (t:Teacher) REQUIRE t.teacher_id IS UNIQUE",
            "CREATE CONSTRAINT student_id_unique IF NOT EXISTS FOR (s:Student) REQUIRE s.student_id IS UNIQUE",
            "CREATE CONSTRAINT question_id_unique IF NOT EXISTS FOR (q:Question) REQUIRE q.question_id IS UNIQUE",
            "CREATE CONSTRAINT assessment_id_unique IF NOT EXISTS FOR (a:Assessment) REQUIRE a.assessment_id IS UNIQUE",
            "CREATE CONSTRAINT resource_id_unique IF NOT EXISTS FOR (r:Resource) REQUIRE r.resource_id IS UNIQUE",
        ]
        
        # Indexes for performance
        indexes = [
            "CREATE INDEX student_name_idx IF NOT EXISTS FOR (s:Student) ON (s.name)",
            "CREATE INDEX question_concept_idx IF NOT EXISTS FOR (q:Question) ON (q.concept_id)",
            "CREATE INDEX assessment_topic_idx IF NOT EXISTS FOR (a:Assessment) ON (a.topic_id)",
        ]
        
        for constraint in constraints:
            try:
                self.neo4j.graph.query(constraint)
                print(f"  âœ… Created constraint: {constraint.split('FOR')[1].split('REQUIRE')[0].strip()}")
            except Exception as e:
                if "already exists" not in str(e).lower():
                    print(f"  âš ï¸  Constraint error: {e}")
        
        for index in indexes:
            try:
                self.neo4j.graph.query(index)
                print(f"  âœ… Created index: {index.split()[2]}")
            except Exception as e:
                if "already exists" not in str(e).lower():
                    print(f"  âš ï¸  Index error: {e}")
        
        print("âœ… Schema initialization complete!")
    
    # ==================== TEACHER MANAGEMENT ====================
    
    def create_teacher(self, teacher_id: str = "teacher", name: str = "Dr. Teacher", 
                      email: str = "teacher@bit.edu") -> Dict[str, Any]:
        """
        Create or update the teacher node in the knowledge graph.
        
        Args:
            teacher_id: Unique identifier for the teacher
            name: Teacher's display name
            email: Teacher's email address
            
        Returns:
            Dictionary containing teacher information
        """
        if self.neo4j is None:
            return {"teacher_id": teacher_id, "name": name, "email": email, "created_at": datetime.now().isoformat()}
        
        query = """
        MERGE (t:Teacher {teacher_id: $teacher_id})
        SET t.name = $name,
            t.email = $email,
            t.created_at = COALESCE(t.created_at, datetime()),
            t.updated_at = datetime()
        RETURN t
        """
        
        result = self.neo4j.graph.query(query, {
            "teacher_id": teacher_id,
            "name": name,
            "email": email
        })
        
        print(f"âœ… Created/Updated teacher: {name}")
        return {
            "teacher_id": teacher_id,
            "name": name,
            "email": email,
            "created_at": datetime.now().isoformat()
        }
    
    def get_teacher_dashboard_data(self, teacher_id: str = "teacher") -> Dict[str, Any]:
        """
        Get comprehensive dashboard data for the teacher.
        
        Returns:
            Dictionary containing:
            - Total students
            - Student performance summaries
            - Areas of struggle across all students
            - Recent activity
        """
        if self.neo4j is None:
            return self._get_mock_teacher_dashboard()
        
        # Get all students and their performance
        query = """
        MATCH (t:Teacher {teacher_id: $teacher_id})-[:MANAGES]->(s:Student)
        OPTIONAL MATCH (s)-[att:ATTEMPTED]->(a:Assessment)
        OPTIONAL MATCH (s)-[mas:HAS_MASTERY]->(c:CONCEPT)
        RETURN s, 
               collect(DISTINCT {assessment: a, attempt: att}) as assessments,
               collect(DISTINCT {concept: c, mastery: mas.level}) as masteries
        """
        
        results = self.neo4j.graph.query(query, {"teacher_id": teacher_id})
        
        students_data = []
        struggling_concepts = {}
        
        for record in results:
            student = record.get('s', {})
            assessments = record.get('assessments', [])
            masteries = record.get('masteries', [])
            
            # Calculate student metrics
            total_assessments = len([a for a in assessments if a.get('assessment')])
            avg_score = sum([a.get('attempt', {}).get('score', 0) for a in assessments]) / max(total_assessments, 1)
            
            # Identify struggling concepts (mastery < 0.5)
            for m in masteries:
                if m.get('mastery', 1.0) < 0.5:
                    concept_name = m.get('concept', {}).get('name', 'Unknown')
                    struggling_concepts[concept_name] = struggling_concepts.get(concept_name, 0) + 1
            
            students_data.append({
                "student_id": student.get('student_id'),
                "name": student.get('name'),
                "total_assessments": total_assessments,
                "average_score": round(avg_score, 2),
                "mastery_level": round(sum([m.get('mastery', 0) for m in masteries]) / max(len(masteries), 1), 2)
            })
        
        return {
            "total_students": len(students_data),
            "students": students_data,
            "struggling_concepts": sorted(struggling_concepts.items(), key=lambda x: x[1], reverse=True)[:10],
            "last_updated": datetime.now().isoformat()
        }
    
    def _get_mock_teacher_dashboard(self) -> Dict[str, Any]:
        """Return mock dashboard data when Neo4j is not available."""
        return {
            "total_students": 0,
            "students": [],
            "struggling_concepts": [],
            "last_updated": datetime.now().isoformat()
        }
    
    # ==================== STUDENT MANAGEMENT ====================
    
    def enroll_student(self, student_id: str, name: str, email: str, 
                      profile_data: Optional[Dict] = None) -> Dict[str, Any]:
        """
        Enroll a new student in the system.
        
        Args:
            student_id: Unique identifier for the student
            name: Student's display name
            email: Student's email address
            profile_data: Additional profile information (learning style, preferences, etc.)
            
        Returns:
            Dictionary containing student information
        """
        if self.neo4j is None:
            return {
                "student_id": student_id,
                "name": name,
                "email": email,
                "enrolled_at": datetime.now().isoformat()
            }
        
        profile_data = profile_data or {}
        
        query = """
        MERGE (s:Student {student_id: $student_id})
        SET s.name = $name,
            s.email = $email,
            s.learning_style = $learning_style,
            s.preferred_domains = $preferred_domains,
            s.enrolled_at = COALESCE(s.enrolled_at, datetime()),
            s.updated_at = datetime()
        WITH s
        MATCH (t:Teacher {teacher_id: 'teacher'})
        MERGE (t)-[:MANAGES]->(s)
        RETURN s
        """
        
        self.neo4j.graph.query(query, {
            "student_id": student_id,
            "name": name,
            "email": email,
            "learning_style": profile_data.get('learning_style', 'visual'),
            "preferred_domains": profile_data.get('preferred_domains', [])
        })
        
        print(f"âœ… Enrolled student: {name}")
        return {
            "student_id": student_id,
            "name": name,
            "email": email,
            "enrolled_at": datetime.now().isoformat()
        }

    def get_student_portfolio(self, student_id: str) -> Dict[str, Any]:
        """
        Get comprehensive portfolio data for a student.

        Returns:
            Dictionary containing:
            - Student profile
            - Progress metrics
            - Mastery levels per concept
            - Completed assessments
            - Recommended next steps
        """
        if self.neo4j is None:
            return self._get_mock_student_portfolio(student_id)

        query = """
        MATCH (s:Student {student_id: $student_id})
        OPTIONAL MATCH (s)-[mas:HAS_MASTERY]->(c:CONCEPT)
        OPTIONAL MATCH (s)-[att:ATTEMPTED]->(a:Assessment)
        OPTIONAL MATCH (c)<-[:HAS_CONCEPT]-(t:TOPIC)
        RETURN s,
               collect(DISTINCT {concept: c.name, mastery: mas.level, topic: t.name}) as concept_masteries,
               collect(DISTINCT {
                   assessment_id: a.assessment_id,
                   topic: a.topic_name,
                   score: att.score,
                   completed_at: att.completed_at
               }) as assessments
        """

        result = self.neo4j.graph.query(query, {"student_id": student_id})

        if not result:
            return self._get_mock_student_portfolio(student_id)

        record = result[0]
        student = record.get('s', {})
        concept_masteries = record.get('concept_masteries', [])
        assessments = record.get('assessments', [])

        # Calculate overall progress
        total_concepts = len(concept_masteries)
        mastered_concepts = len([c for c in concept_masteries if c.get('mastery', 0) >= 0.8])
        avg_mastery = sum([c.get('mastery', 0) for c in concept_masteries]) / max(total_concepts, 1)

        # Group by topics
        topic_progress = {}
        for cm in concept_masteries:
            topic = cm.get('topic', 'General')
            if topic not in topic_progress:
                topic_progress[topic] = {'concepts': [], 'avg_mastery': 0}
            topic_progress[topic]['concepts'].append(cm)

        for topic in topic_progress:
            concepts = topic_progress[topic]['concepts']
            topic_progress[topic]['avg_mastery'] = sum([c.get('mastery', 0) for c in concepts]) / len(concepts)

        return {
            "student_id": student_id,
            "name": student.get('name', 'Unknown'),
            "overall_progress": {
                "total_concepts": total_concepts,
                "mastered_concepts": mastered_concepts,
                "average_mastery": round(avg_mastery, 2),
                "completion_percentage": round((mastered_concepts / max(total_concepts, 1)) * 100, 1)
            },
            "topic_progress": topic_progress,
            "recent_assessments": sorted(assessments, key=lambda x: x.get('completed_at', ''), reverse=True)[:5],
            "last_updated": datetime.now().isoformat()
        }

    def _get_mock_student_portfolio(self, student_id: str) -> Dict[str, Any]:
        """Return mock portfolio data when Neo4j is not available."""
        return {
            "student_id": student_id,
            "name": "Student",
            "overall_progress": {
                "total_concepts": 0,
                "mastered_concepts": 0,
                "average_mastery": 0.0,
                "completion_percentage": 0.0
            },
            "topic_progress": {},
            "recent_assessments": [],
            "last_updated": datetime.now().isoformat()
        }

    # ==================== CONTENT MANAGEMENT ====================

    def load_static_content_from_lab_tutor(self, json_file_path: str) -> bool:
        """
        Load the static knowledge base from lab_tutor folder.

        Args:
            json_file_path: Path to the Neo4j export JSON file

        Returns:
            True if successful, False otherwise
        """
        if self.neo4j is None:
            print("Neo4j not available, cannot load static content")
            return False

        try:
            with open(json_file_path, 'r') as f:
                data = json.load(f)

            # Load topics
            topics = data.get('topics', [])
            for topic in topics:
                self.create_topic(topic.get('name'), topic.get('description', ''))

            # Load theories as concepts
            theories = data.get('theories', [])
            for theory in theories:
                # Extract topic from theory metadata or use default
                topic_name = theory.get('topic', 'General')
                self.create_concept(
                    concept_name=theory.get('id', 'unknown'),
                    topic_name=topic_name,
                    definition=theory.get('compressed_text', ''),
                    keywords=theory.get('keywords', [])
                )

            self.static_content_loaded = True
            print(f"âœ… Loaded {len(topics)} topics and {len(theories)} concepts from lab_tutor")
            return True

        except Exception as e:
            print(f"âŒ Error loading static content: {e}")
            return False

    def create_topic(self, topic_name: str, description: str = "") -> Dict[str, Any]:
        """
        Create a new topic node in the knowledge graph.

        Args:
            topic_name: Name of the topic
            description: Description of the topic

        Returns:
            Dictionary containing topic information
        """
        if self.neo4j is None:
            return {"name": topic_name, "description": description}

        query = """
        MERGE (t:TOPIC {name: $name})
        SET t.description = $description,
            t.created_at = COALESCE(t.created_at, datetime()),
            t.updated_at = datetime()
        RETURN t
        """

        self.neo4j.graph.query(query, {
            "name": topic_name,
            "description": description
        })

        return {"name": topic_name, "description": description}

    def create_concept(self, concept_name: str, topic_name: str,
                      definition: str = "", keywords: List[str] = None) -> Dict[str, Any]:
        """
        Create a new concept node and link it to a topic.

        Args:
            concept_name: Name of the concept
            topic_name: Name of the parent topic
            definition: Definition/description of the concept
            keywords: List of keywords associated with the concept

        Returns:
            Dictionary containing concept information
        """
        if self.neo4j is None:
            return {"name": concept_name, "topic": topic_name}

        keywords = keywords or []

        query = """
        MERGE (c:CONCEPT {name: $concept_name})
        SET c.definition = $definition,
            c.keywords = $keywords,
            c.created_at = COALESCE(c.created_at, datetime()),
            c.updated_at = datetime()
        WITH c
        MERGE (t:TOPIC {name: $topic_name})
        MERGE (t)-[:HAS_CONCEPT]->(c)
        RETURN c
        """

        self.neo4j.graph.query(query, {
            "concept_name": concept_name,
            "topic_name": topic_name,
            "definition": definition,
            "keywords": keywords
        })

        return {"name": concept_name, "topic": topic_name, "definition": definition}

    def update_topic(self, topic_name: str, new_name: str = None, new_description: str = None) -> bool:
        """
        Update an existing topic (for teacher's knowledge graph curation).

        Args:
            topic_name: Current name of the topic
            new_name: New name for the topic (optional)
            new_description: New description (optional)

        Returns:
            True if successful, False otherwise
        """
        if self.neo4j is None:
            return False

        updates = []
        params = {"topic_name": topic_name}

        if new_name:
            updates.append("t.name = $new_name")
            params["new_name"] = new_name

        if new_description:
            updates.append("t.description = $new_description")
            params["new_description"] = new_description

        if not updates:
            return False

        query = f"""
        MATCH (t:TOPIC {{name: $topic_name}})
        SET {', '.join(updates)}, t.updated_at = datetime()
        RETURN t
        """

        result = self.neo4j.graph.query(query, params)
        return len(result) > 0

    def delete_topic(self, topic_name: str) -> bool:
        """
        Delete a topic and all its relationships (for teacher's knowledge graph curation).

        Args:
            topic_name: Name of the topic to delete

        Returns:
            True if successful, False otherwise
        """
        if self.neo4j is None:
            return False

        query = """
        MATCH (t:TOPIC {name: $topic_name})
        DETACH DELETE t
        """

        self.neo4j.graph.query(query, {"topic_name": topic_name})
        print(f"ðŸ—‘ï¸  Deleted topic: {topic_name}")
        return True

    # ==================== ASSESSMENT & QUESTION MANAGEMENT ====================

    def create_assessment(self, assessment_id: str, topic_name: str,
                         assessment_type: str = "pre_topic",
                         questions: List[str] = None) -> Dict[str, Any]:
        """
        Create a new assessment for a topic.

        Args:
            assessment_id: Unique identifier for the assessment
            topic_name: Name of the topic this assessment covers
            assessment_type: Type of assessment (pre_topic, post_topic, graded_quiz)
            questions: List of question IDs included in this assessment

        Returns:
            Dictionary containing assessment information
        """
        if self.neo4j is None:
            return {
                "assessment_id": assessment_id,
                "topic_name": topic_name,
                "type": assessment_type,
                "created_at": datetime.now().isoformat()
            }

        questions = questions or []

        query = """
        MERGE (a:Assessment {assessment_id: $assessment_id})
        SET a.topic_name = $topic_name,
            a.type = $assessment_type,
            a.question_ids = $questions,
            a.created_at = COALESCE(a.created_at, datetime()),
            a.updated_at = datetime()
        WITH a
        MATCH (t:TOPIC {name: $topic_name})
        MERGE (t)-[:HAS_ASSESSMENT]->(a)
        RETURN a
        """

        self.neo4j.graph.query(query, {
            "assessment_id": assessment_id,
            "topic_name": topic_name,
            "assessment_type": assessment_type,
            "questions": questions
        })

        return {
            "assessment_id": assessment_id,
            "topic_name": topic_name,
            "type": assessment_type,
            "questions": questions,
            "created_at": datetime.now().isoformat()
        }

    def create_question(self, question_id: str, concept_name: str,
                       question_text: str, options: List[str],
                       correct_answer: int, difficulty: str = "medium",
                       generated_by_llm: bool = True) -> Dict[str, Any]:
        """
        Create a new question node linked to a concept.

        Args:
            question_id: Unique identifier for the question
            concept_name: Name of the concept this question tests
            question_text: The actual question text
            options: List of answer options
            correct_answer: Index of the correct answer (0-based)
            difficulty: Difficulty level (easy, medium, hard)
            generated_by_llm: Whether this question was generated by LLM

        Returns:
            Dictionary containing question information
        """
        if self.neo4j is None:
            return {
                "question_id": question_id,
                "concept": concept_name,
                "text": question_text
            }

        query = """
        MERGE (q:Question {question_id: $question_id})
        SET q.concept_id = $concept_name,
            q.text = $question_text,
            q.options = $options,
            q.correct_answer = $correct_answer,
            q.difficulty = $difficulty,
            q.generated_by_llm = $generated_by_llm,
            q.created_at = COALESCE(q.created_at, datetime()),
            q.updated_at = datetime()
        WITH q
        MATCH (c:CONCEPT {name: $concept_name})
        MERGE (c)-[:HAS_QUESTION]->(q)
        RETURN q
        """

        self.neo4j.graph.query(query, {
            "question_id": question_id,
            "concept_name": concept_name,
            "question_text": question_text,
            "options": options,
            "correct_answer": correct_answer,
            "difficulty": difficulty,
            "generated_by_llm": generated_by_llm
        })

        return {
            "question_id": question_id,
            "concept": concept_name,
            "text": question_text,
            "options": options,
            "correct_answer": correct_answer,
            "difficulty": difficulty
        }

    def record_assessment_attempt(self, student_id: str, assessment_id: str,
                                 score: float, answers: Dict[str, int],
                                 time_taken: int = 0) -> Dict[str, Any]:
        """
        Record a student's attempt at an assessment.

        Args:
            student_id: ID of the student
            assessment_id: ID of the assessment
            score: Score achieved (0.0 to 1.0)
            answers: Dictionary mapping question_id to selected answer index
            time_taken: Time taken in seconds

        Returns:
            Dictionary containing attempt information
        """
        if self.neo4j is None:
            return {
                "student_id": student_id,
                "assessment_id": assessment_id,
                "score": score,
                "completed_at": datetime.now().isoformat()
            }

        query = """
        MATCH (s:Student {student_id: $student_id})
        MATCH (a:Assessment {assessment_id: $assessment_id})
        MERGE (s)-[att:ATTEMPTED]->(a)
        SET att.score = $score,
            att.answers = $answers,
            att.time_taken = $time_taken,
            att.completed_at = datetime()
        RETURN att
        """

        self.neo4j.graph.query(query, {
            "student_id": student_id,
            "assessment_id": assessment_id,
            "score": score,
            "answers": [f"{k}:{v}" for k, v in answers.items()],  # Convert dict to list of strings
            "time_taken": time_taken
        })

        return {
            "student_id": student_id,
            "assessment_id": assessment_id,
            "score": score,
            "completed_at": datetime.now().isoformat()
        }

    def update_student_mastery(self, student_id: str, concept_name: str,
                              mastery_level: float) -> bool:
        """
        Update a student's mastery level for a specific concept.

        Args:
            student_id: ID of the student
            concept_name: Name of the concept
            mastery_level: Mastery level (0.0 to 1.0)

        Returns:
            True if successful, False otherwise
        """
        if self.neo4j is None:
            return False

        query = """
        MATCH (s:Student {student_id: $student_id})
        MATCH (c:CONCEPT {name: $concept_name})
        MERGE (s)-[m:HAS_MASTERY]->(c)
        SET m.level = $mastery_level,
            m.updated_at = datetime()
        RETURN m
        """

        result = self.neo4j.graph.query(query, {
            "student_id": student_id,
            "concept_name": concept_name,
            "mastery_level": mastery_level
        })

        return len(result) > 0

    # ==================== NEW METHODS FOR ENHANCED FEATURES ====================

    def enroll_student_in_topic(self, student_id: str, topic_name: str) -> Dict[str, Any]:
        """
        Enroll a student in a topic.

        Args:
            student_id: Student ID
            topic_name: Topic name

        Returns:
            Dictionary with enrollment status
        """
        if not self.neo4j:
            return {"success": False, "error": "Neo4j not available"}

        query = """
        MATCH (s:STUDENT {student_id: $student_id})
        MERGE (t:TOPIC {name: $topic_name})
        MERGE (s)-[e:ENROLLED_IN]->(t)
        ON CREATE SET e.enrolled_at = datetime()
        RETURN s, t, e
        """

        try:
            result = self.neo4j.execute_query(query, {
                "student_id": student_id,
                "topic_name": topic_name
            })
            return {"success": True, "message": f"Student enrolled in {topic_name}"}
        except Exception as e:
            return {"success": False, "error": str(e)}

    def record_material_completion(self,
                                   student_id: str,
                                   topic_name: str,
                                   concept_name: str,
                                   time_spent: int) -> Dict[str, Any]:
        """
        Record that a student completed a learning material.

        Args:
            student_id: Student ID
            topic_name: Topic name
            concept_name: Concept name
            time_spent: Time spent in seconds

        Returns:
            Dictionary with completion status
        """
        if not self.neo4j:
            return {"success": False, "error": "Neo4j not available"}

        query = """
        MATCH (s:STUDENT {student_id: $student_id})
        MATCH (t:TOPIC {name: $topic_name})
        MERGE (c:CONCEPT {name: $concept_name})
        MERGE (c)-[:BELONGS_TO]->(t)
        MERGE (s)-[comp:COMPLETED_MATERIAL]->(c)
        SET comp.completed_at = datetime(),
            comp.time_spent = $time_spent
        RETURN s, c, comp
        """

        try:
            result = self.neo4j.execute_query(query, {
                "student_id": student_id,
                "topic_name": topic_name,
                "concept_name": concept_name,
                "time_spent": time_spent
            })
            return {"success": True, "message": f"Material completion recorded"}
        except Exception as e:
            return {"success": False, "error": str(e)}

